from pydantic import BaseModel, Field, ValidationError
from typing import Dict, Type, Any, Optional, Literal, List
import inspect

from src.agent.tool import base_tool
from src.runtime import subprocess_python_executor
from src.runtime import workspace
class ExecutePythonCodeTool(base_tool.BaseTool):
    """
    description:
        Executes valid Python code snippets, returns the console output generated by the code (e.g., printed results, return values) or detailed error messages (e.g., syntax errors, runtime errors) if execution fails.
    note:
        1. Compatible with Python versions 3.12
        2. The code environment (e.g., global variables, global functions, except modules) that was executed last time still exists and can be used directly. 
        3. modules must be included in the code snippet if needed.
        4. Be careful not to conflict with the naming.
    """
    python_code_snippet: str = Field(
        ..., 
        description=(
            "The valid Python code snippet to be executed. Must not contain malicious code (e.g., code that modifies system files, accesses sensitive data, or executes infinite loops). Code should be self-contained unless dependencies are specified in 'execution_context'"
        ),
        examples=["print('Hello, World!')"]
    )
    timeout: int = Field(
        30, 
        description="The maximum time in seconds allowed for the code to execute. If the code runs longer than this, it will be terminated and an error message will be returned."
    )

    def run(self) -> str:
        execution_context: Optional[Dict[str, Any]] = workspace.get_arg_globals()
        exec_result: subprocess_python_executor.ExecutionResult =  subprocess_python_executor.run_structured_in_subprocess(
            command=self.python_code_snippet, 
            _globals=execution_context,
            timeout=self.timeout
        )
        workspace.append_out_globals(exec_result.arg_globals)
        return exec_result.ret_tool2llm
