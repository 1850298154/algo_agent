
你不要用求解器的方法，你就把它当做推箱子、滑块、华容道，来回移动不同的agent，每一栋一次存下来图片，用glm-4.6v看一下图片并给出下一步应该移动哪个智能体、往哪里移动，首先一定有答案，你只需要一直尝试直到找到方法。

我给你个思路，左边智能体，先去上个面和上面智能体汇合贴住上面智能体（但是不要碰撞上面的智能体），这样就可以把左边的路腾出来。右边智能体直接往左走，可以无阻碍的到左边，第一个左边智能体到达右边终点。然后把位于上面的左边智能体，向下走出来到交叉中心，然后再向右走，左边智能体叨叨右边终点，这一左右两个智能体都解决。 最后上面的智能体先向下，再向右走到右边道路中，下面智能体可以无阻碍的一直向上走到目标，下面智能体到达终点；然后位于右边的上面智能体回到中间交叉道路，再往下走，就可以到达终点，第四个也到达终点。你可以一个一个移动，并且可以切换一会移动agnet1，一会移动agnet2等等还会切换操作）。

提示：学会利用拐弯。

你需要不断尝试，直到生成没有碰撞为止的方案：
读取JSON文件，理解场景
while 没有找到方案:
    可视化场景
    调用视觉模型glm-4.6v分析
    设计推箱子、玩华容道的类似策略
    实现算法求解并将结果存到一个子文件夹
    验证碰撞（移动速度是1秒0.5单位长度，必须按照1s的频率来仿真，智能体之间不能碰撞，与障碍物也不能碰撞）
生成每一刻的动画图片


输入场景数据 02.十字街道死锁场景示意图.json


我给你个思路，先让上面走到下面，再让左边走到上面，再让右边走到左边，再让走到上面的从左边出发的智能体往下走到中间，再往右走。可以用glm-4.6v分析每一步的情况，详细规划一下，时间上怎么走，走到哪里（记得不仅要给图片，还要给详细问题和输入数据），可以完全串行（agent之间不用同时移动）。

你需要不断尝试，直到生成没有碰撞为止的方案：
读取JSON文件，理解场景
可视化场景
调用视觉模型glm-4.6v分析
设计行动的策略（每次如果要碰撞，则停下来报告，不要继续执行了，如果agent距离等于1+1不算是碰撞(看上去是贴边了)，浮点数计算有误差）
实现算法求解并将结果存到一个子文件夹
验证碰撞（移动速度是1秒0.5单位长度，必须按照1s的频率来仿真，智能体之间不能碰撞，与障碍物也不能碰撞）
生成动画图片

输入场景数据01.T字街道死锁场景示意图.json。